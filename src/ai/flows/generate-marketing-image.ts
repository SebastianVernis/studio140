'use server';

/**
 * @fileOverview Image generation flow for creating marketing images based on a given topic, platform, image type, and an optional base image.
 *
 * New workflow:
 * 1. Mistral generates an optimized image prompt
 * 2. Gemini analyzes the prompt and generates the image
 * 3. For existing prompts, both AIs generate independent images
 *
 * - generateMarketingImage - Generates a marketing image.
 * - generateDualMarketingImages - Generates two images when existing prompt is detected.
 * - GenerateMarketingImageInput - Input type for the function.
 * - GenerateMarketingImageOutput - Output type for the function.
 */

import { mistralClient, mistralModel, geminiImageModel } from '@/ai/config';
import { z } from 'zod';

const GenerateMarketingImageInputSchema = z.object({
  topic: z
    .string()
    .describe('The topic, subject, or refinement instruction for the marketing image.'),
  platform: z
    .string()
    .optional()
    .describe(
      'The target social media platform (e.g., Instagram, Facebook). This helps guide the overall style.'
    ),
  imageType: z
    .string()
    .optional()
    .describe(
      'The type of image to generate, including dimension hints (e.g., "Instagram Story (1080x1920px)", "Facebook Square Post (1200x1200px)"). This helps guide the style and aspect ratio.'
    ),
  baseImageDataUri: z
    .string()
    .optional()
    .describe(
      "An optional base image as a data URI that must include a MIME type and use Base64 encoding. Expected format: 'data:<mimetype>;base64,<encoded_data>'. If provided, the generated image will be influenced or refined based on this image."
    ),
  isExistingPrompt: z
    .boolean()
    .optional()
    .describe(
      'Whether this is a previously created prompt that should trigger dual image generation.'
    ),
});

export type GenerateMarketingImageInput = z.infer<typeof GenerateMarketingImageInputSchema>;

const GenerateMarketingImageOutputSchema = z.object({
  imageUrl: z
    .string()
    .describe(
      'The generated marketing image as a data URI that must include a MIME type and use Base64 encoding. Expected format: data:<mimetype>;base64,<encoded_data>.'
    ),
  mistralImageUrl: z
    .string()
    .optional()
    .describe('Additional image generated by Mistral-optimized prompt (only for dual generation).'),
});

export type GenerateMarketingImageOutput = z.infer<typeof GenerateMarketingImageOutputSchema>;

// Cache for storing generated prompts to detect duplicates
const promptCache = new Map<string, string>();

async function generateOptimizedPrompt(input: GenerateMarketingImageInput): Promise<string> {
  const mistralPrompt = `You are an expert image prompt engineer. Create a detailed, optimized prompt for generating a marketing image.

Topic: ${input.topic}
Platform: ${input.platform || 'Generic'}
Image Type: ${input.imageType || 'Standard marketing image'}
Base Image: ${input.baseImageDataUri ? 'Yes (will be refined)' : 'No'}

Create a detailed prompt that includes:
- Visual style and composition
- Color palette suggestions
- Mood and atmosphere
- Technical specifications for the platform
- Creative elements that make the image engaging

${
  input.baseImageDataUri
    ? 'This prompt will be used to refine an existing base image.'
    : 'This prompt will be used to generate a new image from scratch.'
}

Respond with only the optimized prompt text, no additional formatting or explanation.`;

  try {
    const response = await mistralClient.chat.complete({
      model: mistralModel,
      messages: [
        {
          role: 'user',
          content: mistralPrompt,
        },
      ],
    });

    const optimizedPrompt = response.choices[0]?.message?.content;
    if (!optimizedPrompt) {
      throw new Error('No prompt received from Mistral API');
    }

    // Handle both string and ContentChunk[] types
    const promptText =
      typeof optimizedPrompt === 'string' ? optimizedPrompt : String(optimizedPrompt);
    return promptText.trim();
  } catch (error) {
    console.error('Error generating optimized prompt with Mistral:', error);
    // Fallback to basic prompt if Mistral fails
    return generateFallbackPrompt(input);
  }
}

function generateFallbackPrompt(input: GenerateMarketingImageInput): string {
  let textPrompt = '';

  if (input.baseImageDataUri) {
    textPrompt = `Refine or modify the provided base image using the following instruction or theme: "${input.topic}".`;
  } else {
    textPrompt = `Generate a sophisticated and conceptually rich marketing image for the topic: "${input.topic}".`;
  }

  textPrompt += ` The image should be visually engaging and thought-provoking.`;
  textPrompt += ` Consider a dynamic composition, symbolic elements, or a unique artistic interpretation related to the instruction/topic.`;

  if (input.platform && input.imageType) {
    textPrompt += ` Optimize for ${input.platform}, specifically for a ${input.imageType} format.`;
  } else if (input.platform) {
    textPrompt += ` Optimize for ${input.platform}.`;
  } else if (input.imageType) {
    textPrompt += ` The image should be a ${input.imageType}.`;
  }
  textPrompt += ` Aim for a high-quality, professional, and modern aesthetic. Avoid overly simplistic or generic representations. Strive for an image that sparks curiosity and complements the core message.`;

  return textPrompt;
}

async function generateImageWithGemini(prompt: string, baseImageDataUri?: string): Promise<string> {
  try {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const parts: any[] = [];

    if (baseImageDataUri) {
      // Extract the base64 data and mime type
      const [mimeInfo, base64Data] = baseImageDataUri.split(',');
      if (!mimeInfo || !base64Data) {
        throw new Error('Invalid base image data URI format');
      }
      const mimeType = mimeInfo.split(':')[1]?.split(';')[0];
      if (!mimeType) {
        throw new Error('Could not extract MIME type from base image data URI');
      }

      parts.push({
        inlineData: {
          data: base64Data,
          mimeType: mimeType,
        },
      });
    }

    parts.push({ text: prompt });

    const result = await geminiImageModel.generateContent({
      contents: [{ role: 'user', parts }],
      generationConfig: {
        temperature: 0.7,
        topK: 40,
        topP: 0.95,
      },
      // Simplified safety settings to avoid type issues
    });

    const response = await result.response;

    // Check if the response contains an image
    if (response.candidates && response.candidates[0]?.content?.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
          return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
        }
      }
    }

    throw new Error('No image generated by Gemini');
  } catch (error) {
    console.error('Error generating image with Gemini:', error);
    throw new Error(
      `Failed to generate image with Gemini: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}

export async function generateMarketingImage(
  input: GenerateMarketingImageInput
): Promise<GenerateMarketingImageOutput> {
  // Check if this is an existing prompt (simplified check based on topic)
  const cacheKey = `${input.topic}-${input.platform}-${input.imageType}`;
  const isExistingPrompt = input.isExistingPrompt || promptCache.has(cacheKey);

  if (isExistingPrompt) {
    return generateDualMarketingImages(input);
  }

  // Step 1: Generate optimized prompt with Mistral
  const optimizedPrompt = await generateOptimizedPrompt(input);

  // Store in cache for future duplicate detection
  promptCache.set(cacheKey, optimizedPrompt);

  // Step 2: Generate image with Gemini using the optimized prompt
  const imageUrl = await generateImageWithGemini(optimizedPrompt, input.baseImageDataUri);

  return { imageUrl };
}

export async function generateDualMarketingImages(
  input: GenerateMarketingImageInput
): Promise<GenerateMarketingImageOutput> {
  try {
    // Generate two different prompts/approaches
    const [mistralPrompt, fallbackPrompt] = await Promise.all([
      generateOptimizedPrompt(input),
      Promise.resolve(generateFallbackPrompt(input)),
    ]);

    // Generate two images in parallel
    const [geminiImage, mistralOptimizedImage] = await Promise.all([
      generateImageWithGemini(fallbackPrompt, input.baseImageDataUri),
      generateImageWithGemini(mistralPrompt, input.baseImageDataUri),
    ]);

    return {
      imageUrl: geminiImage,
      mistralImageUrl: mistralOptimizedImage,
    };
  } catch (error) {
    console.error('Error in dual image generation:', error);
    // Fallback to single image generation
    const fallbackPrompt = generateFallbackPrompt(input);
    const imageUrl = await generateImageWithGemini(fallbackPrompt, input.baseImageDataUri);
    return { imageUrl };
  }
}
